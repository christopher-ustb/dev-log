---
title: 虚拟机类加载机制
date: 2016-10-23 11:57:50
categories: 
- Java
tags:
- java
- jvm
- 读书笔记
---

# 虚拟机类加载机制

## 概述

类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

由于不需要在编译时进行连接，java语言的类型加载、连接和初始化过程都是运行期完成，这样的策略可以提供更高的灵活性：
* 面向接口的应用程序，在运行期再指定实际的实现类。
* 用户通过自定义的类加载器，让一个本地的应用程序可以在运行期从网络或者其他地方加载一个二进制流作为程序的一部分，如JSP、OSGi技术。

## 类加载的时机

类的整个生命周期包括：

1. 加载(Loading)
2. 验证(Verification)
3. 准备(Preparation)
4. 解析(Resolution)
5. 初始化(Intialization)
6. 使用(Using)
7. 卸载(Unloading)

jvm规范严格规定了 *有且只有* 5种情况必须对类进行初始化：

1. 使用new实例化对象、读取或设置一个类的静态字段（static final修饰的除外）、调用一个类的静态方法
2. java.lang.reflect包对类进行反射调用
3. 初始化一个类，如果发现其父类没有初始化，需要先初始化其父类；但是接口不会先初始化其父类接口
4. 虚拟机启动时，会先初始化执行主类（包含main()方法的类）
5. 当使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic/REF_putStatic/REF_invokeStatic的方法句柄对应的类没有初始化时，先触发其初始化

这5中场景中的行为称为对一个类进行主动引用，除此之外，所以引用类的方式都不会触发初始化，称为被动引用。

被动引用举例：

* 通过子类引用父类的静态字段，不会导致子类初始化

	```java
	public class SuperClass {
		static {
			System.out.println("SuperClass init");
		}
		public static int value = 123;
	}

	public class SubClass extends SuperClass {
		static {
			System.out.println("SubClass init");
		}
	}

	public class NoInitialization {
		public static void main(String[] args) {
			System.out.println(SubClass.value);
		}
	}
	```

* 通过数组定义来引用类，不会触发该类的初始化

	```java
	public class NoInitialization {
		public static void main(String[] args) {
			SuperClass[] sca = new SuperClass[10];
		}
	}
	```

	此处没有初始化SuperClass，但是触发了一个叫做"[Lpackagename.SuperClass"的类的初始化。这个类有虚拟机自动生成，直接继承自Object类。

* 引用常量不会触发初始化

	```java
	public class ConstClass {
		static {
			System.out.println("ConstClass init");
		}
		public static final String HELLOWORLD = "hello world!";
	}

	public class NoInitialization {
		public static void main(String[] args) {
			System.out.println(ConstClass.HELLOWORLD);
		}
	}
	```

	这个在java中叫做常量传播优化，在编译阶段，已经将常量的值"hello world!"存储到NoInitialization类的常量池中，以后NoInitialization对ConstClass.HELLOWORLD的引用实际上都转换为对自身常量池的引用，与ConstClass没有关系了。

## 类加载的过程

1. 加载
	
	加载阶段虚拟机完成以下任务：
	1. 通过一个类的全限定名来获取定义此类的二进制字节流

		jvm从未具体指定如何获取二进制字节流的方式，于是发展出了许多多样的加载方式：

		* 从zip包读取，这是JAR/EAR/WAR格式的基础
		* 从网络获取，如Applet
		* 运行时计算生成，如动态代理技术，在java.lang.reflect.Proxy中使用了ProxyGenerator.generateProxyClass来生成"*$Proxy"的代理类字节流
		* 由其他文件生成，如JSP

	2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	3. 在内存中生成一个java.lang.Class对象（并没有明确规定是在java堆中，HotSpot中，虽然Class对象是对象，但是存放在方法区中），作为方法区这个类的各种数据的访问入口

2. 验证

	1. 文件格式验证

		验证字节流是否符合class文件格式的规范，是否能被当前虚拟机处理。

		* 魔数0xCAFEBABE开头
		* 版本号
		* 常量池索引是否有指向不存在的常量
		* CONSTANT_Utf8_info是否有不适合UTF-8的数据

	2. 元数据验证

		对字节码进行语义分析，以保证其符合java语言规范。

		* 这个类是否有父类
		* 是否继承了不允许被继承final的类
		* 如果不是抽象类，是否实现了父类或者接口中要求实现的所有方法
		* 类中字段、方法是否矛盾

	3. 字节码验证

		通过数据流或控制流分析，确定程序语义是否合法、符合逻辑，对类的方法体进行校验分析。

		* 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作
		* 保证跳转指令不会跳转到方法体之外的字节码指令上
		* 保证方法体中的类型转换是有效的

	4. 符号引用验证

		* 符号引用中通过字符串描述的全限定名是否能找到类
		* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
		* 访问性(private, protected, public, default)是否可达

