---
title: 虚拟机字节码执行引擎
date: 2016-10-29 21:05:59
categories: 
- Java
tags:
- java
- jvm
- 读书笔记
---

# 虚拟机字节码执行引擎

## 概述

执行引擎是Java虚拟机的最核心组成部分。JVM规范制定了字节码执行引擎的模型概念，称为执行引擎的统一外观(Facade)：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。

每个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈从入栈到出栈的过程。

在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中(参考[类文件结构](./类文件结构))，因此一个栈帧需要分配多少内存，不会受到程序运行期间变量数据的影响，仅仅取决于具体的jvm实现。

一个线程中的方法调用链可能很长，对活动线程来说，只有位于栈顶的栈帧才是有效的，称之为当前栈帧(Current Stack Frame)，与这个栈帧相关联的方法称为当前方法(Current Method)。

### 局部变量表

局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽(Variable Slot)为最小单位。虚拟机规范并没有明确指明一个Slot所占用的内存空间大小，只是很有导向性地说到每个Slot可以存放一个boolean/byte/char/short/int/float/refrence/returnAddress类型的数据。

在方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表的传递，如果执行的是实例方法(非static)，那局部变量表的第0位Slot默认是用于传递方法所属对象实例的引用，即关键字this。

为了节省栈帧空间，Slot是可以复用的，当字节码的PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。这样的设计会伴随一些副作用，如系统的GC行为。

局部变量不会像类变量那样存在“准备阶段”：一次赋予系统初始值，一次赋予程序员定义的初始值。所以局部变量不经过初始化是不能使用的。

### 操作数栈

操作数栈(Operand Stack)的每个元素可以是任意的Java数据类型，当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。

### 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法：

* 正常完成出口(Normal Method Invocation Completion)
* 异常完成出口(Abrupt Method Invocation Completion)

方法退出的过程实际上就等同于把当前栈帧出栈：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段的唯一任务，就是确定被调用方法的版本（即调用哪个方法）。因为在Class文件中，一切的方法调用都是存储的符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前所说的直接引用）。

### 解析

调用目标在程序代码写好、编译器进行编译时就能确定下来，这类方法的调用成为解析(Resolution)。

在Java中，主要包括静态方法和私有方法。

解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。

### 分派

1. 静态分派

	重载方法分派：

	```java
	public class StaticDispatch {
		static abstract class Human {}

		static class Man extends Human {}

		static class Woman extends Human {}

		public void sayHello(Human guy){
			System.out.println("hello guy!");
		}

		public void sayHello(Man guy){
			System.out.println("hello gentleman!");
		}

		public void sayHello(Woman guy){
			System.out.println("hello lady!");
		}

		public static void main(String[] args) {
			Human man = new Man();
			Human woman = new Woman();
			StaticDispatch sd = new StaticDispatch();
			sd.sayHello(man);
			sd.sayHello(woman);
		}
	}
	```

	虽然代码中刻意定义了两个静态类型相同但是实际类型不同的变量，但虚拟机在重载时是通过参数的静态类型而不是实际类型作为判定依据，并且静态类型是编译期可知的，因此，javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法的两条invokevirtual指令参数中。

	所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，典型的就是方法重载。

	在很多情况下，重载版本不是“唯一的”，往往只能确定出“更加适合的”版本，这种模糊性在计算机世界十分罕见，主要原因是字面量不需要定义，所以字面量没有显式的静态类型，只能从语言规则上去理解和推断。

2. 动态分派

	方法重写的jvm实现原理，指令invokevirtual的运行时解析过程：

	1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
	2. 如果在C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError
	3. 否则，按照继承关系，从下往上依次对C的各个父类进行第2步的搜索和验证过程
	4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError

	这种在运行期根据实际类型确定方法执行版本的分派过程被称为动态分派。

3. 单分派与多分派

	java是一门静态多分派、动态单分派的语言。

4. 虚拟机动态分派的实现

	稳定优化：为类的方法区建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。

	虚方法表中存放了各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类一致。如果子类重写了这个方法，子类方法表中的地址将会替代为指向子类实现版本的入口地址。

### 动态类型语言支持

1. 动态类型语言

	动态类型语言的关键特征，在于它的类型检查的主体过程是在运行期而不是编译器，如Javascript/Python等。相对的，在编译期就进行类型检查过程的语言，就是常用的静态类型语言，如C++/Java。

	通俗的说，运行时异常，就是只要代码不运行到这一行就不会出现问题。与之相对的连接时异常，即使导致异常的代码在无法执行到的分支，类加载时也照样会抛出异常。

	变量无类型而变量值才有类型，这也是动态类型语言的一个重要特征。

	**静态类型语言在编译期确定类型，最显著的好处，就是编译器可以提供严谨的类型检查，与类型相关的问题就能在编码时及时发现，利于稳定性及代码达到更大规模。而动态语言在运行期确定类型，为开发人员提供了更大的灵活性，在某些静态类型语言中需要大量的臃肿代码来实现的功能，由动态语言来实现可能会更加清晰简洁，于是意味着开发效率的提升。**

2. JDK1.7与动态类型

	详见invokedynamic指令与java.lang.invoke包。

## 基于栈的字节码解释执行引擎

`这里都是编译原理，看不懂。`

### 解释执行

### 基于栈的指令集与基于寄存器的指令集

### 基于栈的解释器执行过程

