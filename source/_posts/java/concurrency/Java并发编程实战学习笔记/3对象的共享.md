---
title: 对象的共享
date: 2017-7-27
categories: 
- Java
tags:
- java
- 多线程
- 读书笔记
---

# 对象的共享

上一章《线程安全性》介绍了如何通过同步来避免多个线程同时访问相同的数据，本章将介绍如何共享和发布对象，从而使之能够安全地有多个线程访问。

## 可见性

当多个线程在没有同步机制的情况下共享数据，可能出现读线程不能按照预期地读取到写线程对共享数据的修改。

重排序：在没有同步的情况下，编译期、处理器以及运行时等，都可能对操作的顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

### 失效数据

除非在每次访问变量时都使用同步，否则很有可能获得该变量的一个失效值。

```java
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this")
    private int value;
    public synchronized int get() {return value;}
    public synchronized void set(int value) {this.value = value;}
}
```

### 非原子的64位操作

当线程在没有同步的情况读取变量，可能得到一个失效值，但至少这个值至少是之前某个线程设置的值，而不是一个随机值：这种安全性保证也被称为最低安全性。

但是非volatile的64位数值（double/long）可能无法保证最低安全性，可能读取到某个值的高32位和另一个值的低32位。

### 加锁与可见性

加锁的含义不仅局限于互斥性，还包含可见性。为了确保所有线程都能看到共享变量的最新值，所有读写操作的线程都必须在同一个锁上同步。

### volatile变量

volatile变量上的操作不会与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile变量总是会返回最新值。

访问volatile变量不会加锁，不会使线程堵塞，是一种比synchronized更轻量级的同步机制。

仅当volatile能简化代码的实现以及对同步策略的验证时，才应该使用。如果在验证正确性时，需要对可见性进行复杂的判断，那么就不要使用volatile。

典型用法：检查某个状态标识以判断是否退出循环。

```java
volatile boolean asleep;
...
    while (!asleep) {
        countSheep();
    }
```

volatile不能保证i++的原子性，除非你确保只有一个线程对变量执行写操作。

使用volatile必须满足以下所有条件：

* 对变量的写入操作不依赖变量的当前值，或者能确定只有单个线程更新变量。
* 该变量不与其他变量一起纳入不变性条件。
* 不需要加锁。

## 发布与逸出

发布（Publish）：使对象在当前作用域之外的代码使用。如：

* 将一个指向该对象的引用保存到其他代码能访问的地方
* 在一个非私有方法中返回该引用
* 将引用传递到其他类的方法中

逸出（Escape）：某个不应该发布的对象被发布。

当某个对象逸出后，你必须假设某个类或线程会误用该对象。这正是使用封装的主要原因：封装使得对程序的正确性分析变得可能，并使无意中破坏设计约束条件变得很难。

## 线程封闭

一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问，就不需要同步，这种技术被称为“线程封闭”。

### 栈封闭

只通过局部变量访问对象。

### ThreadLocal类

ThreadLocal通常用于防止对可变的单实例变量或全局变量共享。

## 不变性

不可变对象一定是线程安全的。

当满足以下条件时，对象才是不可变的：

* 对象创建以后其状态不能修改
* 所有域都是final
* 对象是正确创建的（创建期间this引用没有逸出）

保存在不可变对象中的状态仍然可以更新，即通过一个保存新状态的实例来替换原有的不可变对象。

### final域

除非需要某个域是可变的，否则将其声明为final域，是很好的编程习惯。

## 安全发布





